# ADR-0002: Supabase-native feature flag governance
Status: Accepted
Context: Phase 1 requires feature flag governance to gate every upcoming module. We must provision storage, APIs, UI, and telemetry without introducing a new vendor or rewriting existing systems. Constraints include Supabase as the source of truth, RLS-enforced admin access, typed helpers for Next.js server/client usage, auditability, and observability coverage for `flag_evaluation_latency_ms`.
Decision: Implement a dedicated `feature_flags` table and companion `feature_flag_audit` table in Supabase with RLS policies allowing only admins and the service role. Provide Next.js APIs for admin CRUD and public evaluation backed by Supabase service clients, and emit audit entries on every mutation. Ship a typed SDK (`FeatureFlagKey` union, server helper, React hook) that caches reads, records `flag_evaluation_latency_ms`, and exposes flags to both server and client layers behind the `feature_flags_admin` view in the admin console. Instrument evaluations via a lightweight metrics adapter until the full OpenTelemetry pipeline lands in `OBS-100`.
Consequences: Feature delivery remains behind documented flags with consistent governance and audit trails. Admins can create, update, and review flags without leaving the platform. Telemetry for evaluations primes dashboards defined in `/docs/08-observability.md`. Future modules consume the shared SDK, ensuring consistent gating and rollback controls. We assume Supabase remains the system of record; should a managed vendor be adopted later, we can swap adapters while preserving the SDK surface.
Alternatives: (1) Adopt a third-party flag platform (LaunchDarkly, ConfigCat) — rejected to avoid vendor onboarding, data residency concerns, and inconsistent RLS. (2) Reuse the existing `site_settings` table — rejected because it lacks typed keys, governance metadata, and audit trails per upcoming compliance requirements.
Links: [Ticket GOV-000](../04-backlog.json), [/docs/10-release-plan.md](../10-release-plan.md)
